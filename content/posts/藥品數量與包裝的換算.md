+++
title = '藥品數量與包裝的換算'
slug = 'Medicine-Package-Quantity'
date = 2023-09-11T10:05:30+08:00
draft = true
isCJKLanguage = true
showToc = true
TocOpen = true
categories = ['工具小零件']
tags = ['Python','MySQL','Database','Javascripts','數量換算','包裝量','調藥系統','報表優化','藥品包裝']
+++
## 藥品的包裝
因應台灣醫療改革基金會推行，民眾領到的藥品將以「原包裝」為主。例如原廠包裝 1 盒為 28 顆裝的藥品，當醫師開立超過 28 顆時，藥師就必須發出 1 盒原廠包裝搭配手剪散藥給予民眾。

但是藥品百百種，各家廠商決定包裝的時候可能會參考藥品的使用頻率或生產時的便利性，決定以盒裝生產或是以大容量瓶裝生產，盒裝的藥品裡面又會因為藥品的使用方法等因素而有不同包裝的鋁箔片，而瓶裝藥品則可能有 100 顆裝或 1000 顆裝等情形。

>臺灣或國外大部分的醫院，因為醫師開診固定於一週內的特定幾天，民眾回診時間也因此固定為 7 的倍數，例如民眾可能於禮拜三固定醫師回診，下次回診如果沒有特別調整，應該還是禮拜三。因此大部分藥盒或是藥片的設計都是 7 的倍數。
>
>又：因為這樣的緣故，醫院或處方上面的 1 個月，通常指的是 28 天而不是 30 天。

盒裝數量或瓶裝數量已經很多種了，對於藥庫而言，購買的包裝其實是以「箱」計算，而各家廠商每箱內所含的盒數或是瓶數更是達到了百家爭鳴的盛況。

為了解決各個藥品具有不同包裝量的情形，我們決定將藥品各層包裝分級處理。例如膠囊或是錠劑的藥品，第一級包裝即為「顆」，包裝量為 1 ；第二級包裝可能為「片」，表示該藥品為一片鋁箔片中封有一個囊泡一顆藥品的包裝設計，而鋁箔片上的囊泡數量就是包裝量，可能為 14 。
***
## 資料表設計
為了加速藥庫對於藥品數量的計算，我們決定以資料庫的方式紀錄藥品的包裝量，並且設計一個可以容納前面提過各級包裝單位和包裝量的 Schema (資料表及欄位的設計)。

以藥品 [Bokey 伯基腸溶微粒膠囊](https://info.fda.gov.tw/MLMS/H0001D.aspx?Type=Lic&LicId=01037344) 為例，每片鋁箔片有 28 顆膠囊，每盒內有 35 片鋁箔片，每箱內有 20 盒藥品。
<!--![Bokey](https://druginfo.cmuh.org.tw/drugpic/TASPI100.jpg)-->
{{< figure src="https://druginfo.cmuh.org.tw/drugpic/TASPI100.jpg" width="70%" alt="Bokey Images" align="center" >}}

資料表設計如下：

|自動序號|藥品代碼|藥品名稱|包裝層級|包裝名稱|包裝數量|建立時間|
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|...|BOK001|Bokey 100mg Cap|1|顆|1|20230911131400|
|...|BOK001|Bokey 100mg Cap|2|片|28|20230911131528|
|...|BOK001|Bokey 100mg Cap|3|盒|35|20230911131730|
|...|BOK001|Bokey 100mg Cap|4|箱|20|20230911132001|

為了資料庫比較好建立，包裝數量的定義是**該層級內含多少上一層級的數量**，以 Bokey 的例子來說，層級 3 的盒包裝數量 35 ，表示盒內具有 35 個層級 2 的包裝，也就是 35 片。

因此資料表的結構設計如下：
```MySQL
CREATE TABLE `pkgspec` (
  `id` int(11) NOT NULL,
  `code` varchar(6) NOT NULL,
  `name` varchar(50) NOT NULL,
  `speclevel` tinyint(2) NOT NULL,
  `specname` varchar(4) NOT NULL,
  `specqty` int(11) NOT NULL,
  `buildtime` varchar(14) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

ALTER TABLE `pkgspec`
  ADD PRIMARY KEY (`id`);

ALTER TABLE `pkgspec`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
COMMIT;
```
***
## 資料表應用
大部份的使用情形是**將藥品顆數轉為包裝量**。例如事務員進行藥品調度時，院內系統產生的調度單上面會寫：`需調度 58,800 顆 Bokey 100mg Cap 至門診藥局`。於是事務員就得先計算 58,800 顆是幾箱藥品，才能進行作業。

### Python
這樣的情形可以利用 python 先將院內系統產生的調度單形成 csv 檔後，再利用 Pandas 的 DataFrame 匯入檔案處理數字。

處理數字的部分，就是一連串的除法：
```python
import pandas as pd
import mysql.connector
from sqlalchemy import create_engine

code = 'BOK001'
qty = 58800

sql = f"SELECT * FROM pkgspec WHERE `code` = '{code}' ORDER BY `speclevel`,`buildtime` ASC"
engine = create_engine('mysql+mysqlconnector://...')
df = pd.read_sql(sql, con=engine)

df = df.sort_values(['speclevel','buildtime']).drop_duplicates('speclevel', keep='last')
#避免重複建立的包裝量，因此以speclevel為索引刪掉重複值

df['specqty'] = df['specqty'].cumprod() #累乘
df = df.sort_values('speclevel', ascending=False)[['specname','specqty']].values.tolist()
```
比較重要的方法是 `cumprod()` ，預設參數是 `axis=0` 向下累乘，效果如下：
<!--![Pandas cumprod()](/images/2023-09-cumprod.png)-->
{{< figure src="/images/2023-09-cumprod.png" width="40%" alt="Pandas cumprod()" align="center" >}}

此時的輸出就是 `[['箱', 19600], ['盒', 980], ['片', 28], ['顆', 1]]` ，接下來要做的事就是把 58,800 丟進迴圈裏面相除取餘數、餘數再除取餘數直到列表 (python list) 除完。
```python
output = '' #指定一個變數來接結果
if len(df) == 0:
    output = f'{qty}？'
elif qty <= 0:
    output = f'{qty}{df[-1][0]}'
else:
    first = True
    for specname,specqty in df:
        if first: 
            quotient = qty // specqty
            remainder = qty % specqty
            prevremainder = remainder
            first = False
            if quotient > 0:
                output += f'{quotient}{specname}'
        else:        
            quotient = prevremainder // specqty
            remainder = prevremainder % specqty
            prevremainder = remainder
            if quotient > 0:
                output += f'{quotient}{specname}'
```
接著就是把剛剛寫的程式變成自訂函式：
```python
def pkgcalc(code, qty):
    ...
    return output
```
然後回到原本的讀入 csv 的報表程式中，利用 lambda 表達式帶入自訂函式：
```python
df = pd.read_csv('報表路徑')
df = df[['藥品代碼','藥品名稱','調度量']]
df['調度包裝'] = df.apply(lambda x: pkgcalc(x['藥品代碼'], x['調度量']), axis=1)
```
如此就可以在報表中直接顯示成 `需調度 5 箱 Bokey 100mg Cap 至門診藥局` ，一目了然。
### PHP
有時候的需求是在網頁報表上呈現包裝量，因為個人習慣問題，所有的網頁報表都是使用 PHP 加上少部分的 javascript 完成的。如果今天使用 django 架構網站，便可以直接利用以上函式轉換。

把剛剛的 python 用 PHP 重新寫一次：
```php
function pkgcalc($code, $qty){
    //連接資料庫
    $conn = new PDO("mysql:host=;dbname=;charset=", "帳號", "密碼");
    $conn->exec("SET NAMES utf8");
    $sql = "SELECT * FROM pkgspec WHERE `code` = '$code' ORDER BY `speclevel`,`buildtime` ASC";
    $stmt = $conn->query($sql);
    //匯出該代碼所有資料
    $allrows = $stmt->fetchAll(PDO::FETCH_ASSOC);
    //只取得相同階層之最新日期資料
    foreach ($allrows as $allrow) {
        $rows[$allrow["speclevel"]] = $allrow;
    }
    //計算階乘數
    foreach ($rows as $key=>$val) {
        $rows[$key]["cumproduct"] = array_product(array_slice(array_column($rows,"specqty"),0,$key));
    }
    //重新排序陣列
    krsort($rows);
    //開始計算數量
    if (intval($qty)<=0) {
        return strval($qty).array_slice($rows,-1)[0]["specname"];
    }
    $result = "";
    foreach ($rows as $key=>$val) {
        if ($key==count($rows)){
            $rows[$key]["quotient"] = intval($qty / $rows[$key]["cumproduct"]);
            $rows[$key]["remainder"] = $qty % $rows[$key]["cumproduct"];
            $prevremainder = $rows[$key]["remainder"];
            if ($rows[$key]["quotient"] > 0){
                $result .= number_format(strval($rows[$key]["quotient"])).strval($rows[$key]["specname"])." ";
            }
        }else{
            $rows[$key]["quotient"] = intval($prevremainder / $rows[$key]["cumproduct"]);
            $rows[$key]["remainder"] = $prevremainder % $rows[$key]["cumproduct"];
            $prevremainder = $rows[$key]["remainder"];
            if ($rows[$key]["quotient"] > 0){
                $result .= number_format(strval($rows[$key]["quotient"])).strval($rows[$key]["specname"])." ";
            }
        }
    }
    return trim($result);
}
```
實際上應用如下，範例圖片還用了 bootstrap 的 tooltips 設計：
![PHP pkgcalc](/images/2023-09-php-pkgcalc.png#center)
***
## 資料表的新增修改刪除
資料表的傳統維護，就是基礎的新增修改刪除，其實不難，直接用 php 寫一張 UI 出來使用 My SQL 簡單操作資料表即可。
![pkgcalc CRUD UI](/images/2023-09-pkgcalc-crud-ui.png#center)

比較困難的地方是要與院內的藥品品項同步。當有新增品項時，必須隨著藥品種類帶入預設值，例如：嗽藥水的一級包裝名稱是「瓶」，針劑的一級包裝名稱是「支」。當院內品項被刪除時，原則上可以保留資料表中資料，只是不使用所以不影響。

因此該資料表必須使用 python 每天和院內系統匯出的藥品品項進行比對，如果資料有差集，必須判斷後自行新增預設值進資料表中。
```python
import pandas as pd
import mysql.connector
from sqlalchemy import create_engine
engine = create_engine('mysql+mysqlconnector://...')
df = pd.read_excel('院內系統匯出的藥品品項.xls', dtype=str)
pkgspec = pd.read_sql('SELECT DISTINCT `code` FROM `pkgspec`', con=engine)
```
兩個集合 `df` 、 `pkgspec` 的資料取單一邊的差集。
```python
new_insert = list(set(df['藥品代碼'].tolist()) - set(pkgspec['code'].tolist()))
pkgspec_time = pd.to_datetime('now').strftime('%Y%m%d%H%M%S')
```
將差集資料以預設值新增進資料表中，並且只先完成第一層級的資料。
```python
for code in new_insert:
    name = df.loc[df['藥品代碼']==code, '藥品名稱'].values[0]
    specname = df.loc[df['藥品代碼']==code, '院內設定包裝'].values[0]
    engine.execute(f"INSERT INTO `pkgspec` (`id`, `code`, `name`, `specname`, `specqty`, `speclevel`, `buildtime`) VALUES (NULL, '{code}', '{name}', '{specname}', '1', '1', '{pkgspec_time}');")
```
如果不先新增預設值，那上面寫了兩個小工具在碰到新的藥品代碼時候，都會跳出錯誤造成程式中止。所以要嘛就是要在小程式中加入例外來帶入預設值，避免錯誤中止程式；要嘛就是每日檢查新的藥品代碼。為了維持資料在最新的狀態，後來選擇了後者，畢竟如果寫了太多的 try 、 exception ，會忘記到底為什麼程式跑不出來也是挺麻煩的。
***
## 其他的應用實例
### 藥品盤點單
![PkgCalc Intracounts](/images/2023-09-intracounts.png)
### 調藥系統