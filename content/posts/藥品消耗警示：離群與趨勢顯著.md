+++
title = '藥品消耗警示：離群與趨勢顯著'
slug = 'consumption-alert-outlier-tendency'
date = 2023-09-19T08:02:40+08:00
draft = true
isCJKLanguage = true
showToc = true
TocOpen = true
categories = ['資料視覺化']
tags = ['Python','MySQL','Database','Chartjs','PHP','MariaDB','Data Visualization','資料視覺化','視覺化','Pandas','DataFrame','資料庫','圖表','Alert','警訊','時間序列','time series','outlier','tendency','離群值','趨勢性']
+++
在[前幾篇](https://lambolyu.netlify.app/2023/09/medicine-consumption-data-visualization/)有提過，我們利用 python 彙整處方資料至資料庫中，顯示出視覺化的圖表以便於讓藥師進行決策。

但是這功能卻僅限於***已經知道特定藥品***出現異常，再輸入該藥品名稱，才會進入該藥品的視覺化圖表去了解異常的區間或異常的情形。

要怎麼***已經知道***？醫院的藥品動輒上千種，以本院為例，藥庫需要掌握的藥品數量大概在 1,500 種上下，因此需要建立額外的方法**直接讓程式篩選**出異常藥品，顯示給藥師。
***
## 藥品消耗資料 = 時間序列資料
比較穩定的藥品消耗資料屬於時間序列資料的一種，部分具有穩定性 (stationary) 、季節性 (seasonality) 和自我相關 (autocorrelation) 的特性，因此可以為每個藥建立簡單的數學模型以描述消耗數量的波動。

>**什麼是不穩定的藥品消耗資料？**
>
>包含零星個案的昂貴藥品、罕見疾病的治療藥物等使用的母群體數量不大，雖然偶有規律性，卻會因為個案或其他原因打斷規律性，導致資料不穩定。

但是醫院藥品的消耗量會受到星期六、星期日兩天只有上午看診或是沒有看診，消耗量大幅降低，甚至沒有消耗，此時的序列資料就會受到影響，而該影響也成為時間序列新的特徵，進而改變模型描述資訊。因為我們要將各藥品之間互相做比較，六日的特徵值比較沒有意義，所以為了避免六日的干擾，我們把整週的消耗量相加，直接利用週跟週之間的消耗量重新形成新的序列，~~類似降維的概念~~，以弭平六日的影響。

![Day to Week](/images/2023-09-daytoweek.png#center)
如上圖，上面兩張圖和下面兩張圖分別為不同藥品，可以觀察到上面的藥品容易受到六日的干擾，程式篩選出異常資料時，可能會其中一種情形視為異常，但其實六日波動對於藥品消耗不是異常情形，改為週總和序列後可以弭平六日的影響，期能使程式將重點放在其他異常情形上。
***
## 程式規劃
由於 php 計算相關的數學模型需要付出的效能以及程式大小已經大大影響使用者體驗，所以偏好將計算與警示的工作交給 python ：
1. 用 python 將資料匯出資料庫後利用函式庫進行科學計算。
2. 形成中繼檔案交由 php 讀取。
3. 中繼的檔案格式不限，但開發時候便於閱讀所以選用 csv 檔。
4. php 在同一個網頁裡面丟給 chartjs 作圖。
![Alert program design](/images/2023-09-alert-design.png#center)

***
## 資料收集與整理
我們需要將原始資料庫裡的資料作以下的整理：
1. 將每一筆消耗量以日期為群組進行相加，得到`日期：日消耗總和`的陣列或字典。
2. 將不連續的`日期：日消耗總和`資料補上連續日期資料，空值補 0 。
3. 將日期重新取樣成每週，並對資料再次進行相加，得到`週序：週消耗總和`的陣列或字典。
4. 將資料改成下圖的形式，對於後續可讀性或操作回饋比較好。
![Alert Data Like](/images/2023-09-alert-data-like.png#center)

先匯出資料庫中的資料，需要決定一個起始日期，例如一年前的當月月初，然後一樣使用 MySQL GROUP BY 查詢返回 SUM 來計算總和：
```python
import pandas as pd
import numpy as np
import mysql.connector
from sqlalchemy import create_engine
engine = create_engine('mysql+mysqlconnector://~')

code = '藥品代碼'

start_day = (pd.to_datetime('today') - pd.tseries.offsets.MonthBegin(13)).strftime('%Y%m%d')
today = pd.to_datetime('today').strftime('%Y%m%d')

# 查詢藥品用量資料
capital = '0' if code[0].isnumeric() else code[0]
sql = f"SELECT `date`,SUM(`total`) AS `qty` FROM `consmp_{capital}` WHERE `drug` = '{code}' AND `date` >= '{startday}' GROUP BY `date`"
df = pd.read_sql(sql=sql, con=engine)
```
### pd.date_range
如同先前 php 的 `new DatePeriod()` 類別建立連續時間的 array ， pandas 則是利用 `.date_range()` 建立一個連續時間的 list 。例如以下的程式碼，就會建立一個從 2023 年 9 月 20 日 00 點 00 分 00 秒為第一個元素並間隔一天新增一個元素的的 DatetimeIndex 物件( python 中也可以視為 list 的一種)：
```python
pd.DataFrame(pd.date_range(start='2023-09-20', end='2023-09-22', freq='D')
```
執行結果如下：
```powershell
DatetimeIndex(['2023-09-20', '2023-09-21', '2023-09-22'], dtype='datetime64[ns]', freq='D')
```
### pd.DataFrame
接著就可以以這個連續日期的 list 直接塞進 `.DataFrame()` 裡面，設定 `columns` 參數，就會變成一張具有連續日期的表，但是因為 `.date_range()` 建立出來的字串是時間戳型別，所以要先用 `.strftime()` 強制轉型：
```python
pd.DataFrame(pd.date_range(start='2023-09-20', end='2023-09-22', freq='D').strftime('%Y%m%d'), columns=['date'])
```
執行結果如下：
```powershell
       date
0  20230920
1  20230921
2  20230922
```
### pd.merge
php 是利用 `foreach()` 直接迭代新的連續時間陣列，並將舊資料逐筆塞入。pandas 則是用 `.merge()` 方法把兩張表合併，我比較常用的操作方法如下：
```python
新表 = pd.merge(左表, 右表,
    on = '以哪一直欄為索引',
    how = '合併方法'
)
```
也是可以寫成：
```python
新表 = 左表.merge(右表,
    on = '以哪一直欄為索引',
    how = '合併方法'
)
```
`how` 是指定左表和右表的結合方式，預設值是 `inner` ，取**交集**索引和該索引的資料：
![Pandas Merge Inner](/images/2023-09-merge-inner.png#center)

如果是 `outer` 表示**聯集**，空出來的格子則會被塞入 `NaN` ：
![Pandas Merge Outer](/images/2023-09-merge-outer.png#center)

其他還有以左表為主的 `left` ，或是右表為主的 `right` ，都很實用：
![Pandas Merge Left](/images/2023-09-merge-left.png#center)
![Pandas Merge Right](/images/2023-09-merge-right.png#center)

### pd.pivot_table
連續時間資料的 DataFrame 與原本總和的 DataFrame 合併之後，資料會長這樣：
![Alert Data After Maerge](/images/2023-09-data-aftermerge.png#center)
接著要把**週序**移到橫列當作 columns name ，需要用到 `pivot_table` 樞紐分析表的功能，下面列舉一些比較常用的參數：
```python
df = pd.pivot_table(
    DataFrames,
    values='',
    index='',
    columns='',
    aggfunc='mean'
)
```
其中 `values` 、 `index` 、 `columns` 要填入來源 DataFrame 的 columns 名稱，其中 `values` 為資料來源， `index` 為列 (row) 的來源， `columns` 為欄 (column) 的來源：
![Pandas DataFrame Pivot](/images/2023-09-pivot-demo-finish.png#center)

如果資料來源有衝突的時候，資料就以 `aggfunc` 的方式處理，預設為取平均值，例如以下的情形就會以 300 和 400 的平均顯示最後結果為 350 ：
![Pandas DataFrame Pivot Conflict](/images/2023-09-pivot-demo-conflict.png#center)

>**其實還有 `pd.pivot()` 可以使用！**
>
>差別在於 `pivot()` 沒有 `aggfunc` 的參數，無法處理衝突值，等於是 `pivot_table` 的簡化版，如果確定資料沒有衝突，又不想多打幾個字，可以只用 `pivot()` 就好。

將以上的方法串聯在一起後，包成自訂函示，然後一樣以 `DataFrame.iterrows()` 遍歷藥品品項檔，最後完成整個樞紐分析表：
```python

```
***
## 最後一點資料是不是離群值？
***
## 趨勢性顯不顯著？

***
## Attribution
- [Icons created by Freepik - Flaticon](https://www.flaticon.com/)