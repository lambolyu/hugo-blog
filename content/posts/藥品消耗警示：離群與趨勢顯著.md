+++
title = '藥品消耗警示：離群與趨勢顯著'
slug = '藥品消耗警示：離群與趨勢顯著'
date = 2023-09-19T08:02:40+08:00
draft = true
isCJKLanguage = true
showToc = true
TocOpen = true
categories = ['資料視覺化']
tags = ['Python','MySQL','Database','Chartjs','PHP','MariaDB','Data Visualization','資料視覺化','視覺化','Pandas','DataFrame','資料庫','圖表','Alert','警訊','時間序列','Time series']
+++
在[前幾篇](https://lambolyu.netlify.app/2023/09/medicine-consumption-data-visualization/)有提過，我們利用 python 彙整處方資料至資料庫中，顯示出視覺化的圖表以便於讓藥師進行決策。

但是這功能卻僅限於***已經知道特定藥品***出現異常，再輸入該藥品名稱，才會進入該藥品的視覺化圖表去了解異常的區間或異常的情形。

要怎麼***已經知道***？醫院的藥品動輒上千種，以本院為例，藥庫需要掌握的藥品數量大概在 1,500 種上下，因此需要建立額外的方法**直接讓程式篩選**出異常藥品，顯示給藥師。
***
## 藥品消耗資料 = 時間序列資料
比較穩定的藥品消耗資料屬於時間序列資料的一種，部分具有穩定性 (stationary) 、季節性 (seasonality) 和自我相關 (autocorrelation) 的特性，因此可以為每個藥建立簡單的數學模型以描述消耗數量的波動。

>**什麼是不穩定的藥品消耗資料？**
>
>包含零星個案的昂貴藥品、罕見疾病的治療藥物等使用的母群體數量不大，雖然偶有規律性，卻會因為個案或其他原因打斷規律性，導致資料不穩定。

但是醫院藥品的消耗量會受到星期六、星期日兩天只有上午看診或是沒有看診，消耗量大幅降低，甚至沒有消耗，此時的序列資料就會受到影響，而該影響也成為時間序列新的特徵，進而改變模型描述資訊。因為我們要將各藥品之間互相做比較，六日的特徵值比較沒有意義，所以為了避免六日的干擾，我們把整週的消耗量相加，直接利用週跟週之間的消耗量重新形成新的序列，~~類似降維的概念~~，以弭平六日的影響。

![Day to Week](/images/2023-09-daytoweek.png#center)
如上圖，上面兩張圖和下面兩張圖分別為不同藥品，可以觀察到上面的藥品容易受到六日的干擾，程式篩選出異常資料時，可能會其中一種情形視為異常，但其實六日波動對於藥品消耗不是異常情形，改為週總和序列後可以弭平六日的影響，期能使程式將重點放在其他異常情形上。
***
## 程式規劃
由於 php 計算相關的數學模型需要付出的效能以及程式大小已經大大影響使用者體驗，所以偏好將計算與警示的工作交給 python ：
1. 用 python 將資料匯出資料庫後利用函式庫進行科學計算。
2. 形成中繼檔案交由 php 讀取。
3. 中繼的檔案格式不限，但開發時候便於閱讀所以選用 csv 檔。
4. php 在同一個網頁裡面丟給 chartjs 作圖。
![Alert program design](/images/2023-09-alert-design.png#center)

***
## 資料收集與整理
我們需要將原始資料庫裡的資料作以下的整理：
1. 將每一筆消耗量以日期為群組進行相加，得到`日期：日消耗總和`的陣列或字典。
2. 將不連續的`日期：日消耗總和`資料補上連續日期資料，空值補 0 。
3. 將日期重新取樣成每週，並對資料再次進行相加，得到`週序：週消耗總和`的陣列或字典。
4. `週序`的表達方式無法直覺運用，可以改為星期日或星期一的日期。

先匯出資料庫中的資料，需要決定一個起始日期，例如一年前的當月月初，然後一樣使用 MySQL GROUP BY 查詢返回 SUM 來計算總和：
```python
import pandas as pd
import numpy as np
import mysql.connector
from sqlalchemy import create_engine
engine = create_engine('mysql+mysqlconnector://~')

code = '藥品代碼'

start_day = (pd.to_datetime('today') - pd.tseries.offsets.MonthBegin(13)).strftime('%Y%m%d')
today = pd.to_datetime('today').strftime('%Y%m%d')

# 查詢藥品用量資料
capital = '0' if code[0].isnumeric() else code[0]
sql = f"SELECT `date`,SUM(`total`) AS `qty` FROM `consmp_{capital}` WHERE `drug` = '{code}' AND `date` >= '{startday}' GROUP BY `date`"
df = pd.read_sql(sql, read_engine)
```
### pd.date_range
利用 `.date_range()` 建立一個連續的時間序列，例如以下的程式碼，就會建立一個以 start_day 開始每天 0 點為一個元素並間隔一天的 DatetimeIndex 物件，但在 python 中也可以視為 list 的一種：
```python
pd.DataFrame(pd.date_range(start='2023-09-20', end='2023-09-22', freq='D')
```
執行結果如下：
```powershell
DatetimeIndex(['2023-09-20', '2023-09-21', '2023-09-22'], dtype='datetime64[ns]', freq='D')
```
### pd.DataFrame
接著就可以以這個連續日期的 list 直接塞進 `.DataFrame()` 裡面，設定 `columns` 參數，就會變成一張具有連續日期的表，但是因為 `.date_range()` 建立出來的字串是時間戳型別，所以要先用 `.strftime()` 強制轉型：
```python
pd.DataFrame(pd.date_range(start='2023-09-20', end='2023-09-22', freq='D').strftime('%Y%m%d'), columns=['date'])
```
執行結果如下：
```powershell
       date
0  20230920
1  20230921
2  20230922
```
### pd.merge
接著就是利用 `.merge()` 方法把兩張表合併，我比較常用的操作方法如下：
```python
新表 = pd.merge(左表, 右表,
    on = '以哪一直欄為索引',
    how = '合併方法'
)
```
也是可以寫成：
```python
新表 = 左表.merge(右表,
    on = '以哪一直欄為索引',
    how = '合併方法'
)
```
看下面的圖片說明：





```python
dayrange = pd.DataFrame(pd.date_range(start=start_day, end=today, freq='D').strftime('%Y%m%d'), columns=['date'])
df = pd.merge(dayrange, df, how='left', on='date').fillna(0)
```

***
## 最後一點資料是不是離群值？
***
## 趨勢性顯不顯著？

***
## Attribution
- [Icons created by Freepik - Flaticon](https://www.flaticon.com/)