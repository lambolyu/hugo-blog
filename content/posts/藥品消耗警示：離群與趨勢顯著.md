+++
title = '藥品消耗警示：離群與趨勢顯著'
slug = '藥品消耗警示：離群與趨勢顯著'
date = 2023-09-19T08:02:40+08:00
draft = true
isCJKLanguage = true
showToc = true
TocOpen = true
categories = ['資料視覺化']
tags = ['Python','MySQL','Database','Chartjs','PHP','MariaDB','Data Visualization','資料視覺化','視覺化','Pandas','DataFrame','資料庫','圖表','Alert','警訊','時間序列','Time series']
+++
在[前幾篇](https://lambolyu.netlify.app/2023/09/medicine-consumption-data-visualization/)有提過，我們利用 python 彙整處方資料至資料庫中，顯示出視覺化的圖表以便於讓藥師進行決策。

但是這功能卻僅限於***已經知道特定藥品***出現異常，再輸入該藥品名稱，才會進入該藥品的視覺化圖表去了解異常的區間或異常的情形。

要怎麼***已經知道***？醫院的藥品動輒上千種，以本院為例，藥庫需要掌握的藥品數量大概在 1,500 種上下，因此需要建立額外的方法**直接讓程式篩選**出異常藥品，顯示給藥師。
***
## 藥品消耗資料 = 時間序列資料
比較穩定的藥品消耗資料屬於時間序列資料的一種，部分具有穩定性 (stationary) 、季節性 (seasonality) 和自我相關 (autocorrelation) 的特性，因此可以為每個藥建立簡單的數學模型以描述消耗數量的波動。

>**什麼是不穩定的藥品消耗資料？**
>
>包含零星個案的昂貴藥品、罕見疾病的治療藥物等使用的母群體數量不大，雖然偶有規律性，卻會因為個案或其他原因打斷規律性，導致資料不穩定。

但是醫院藥品的消耗量會受到星期六、星期日兩天只有上午看診或是沒有看診，消耗量大幅降低，甚至沒有消耗，此時的序列資料就會受到影響，而該影響也成為時間序列新的特徵，進而改變模型描述資訊。因為我們要將各藥品之間互相做比較，六日的特徵值比較沒有意義，所以為了避免六日的干擾，我們把整週的消耗量相加，直接利用週跟週之間的消耗量重新形成新的序列，~~類似降維的概念~~，以弭平六日的影響。

![Day to Week](/images/2023-09-daytoweek.png#center)
如上圖，上面兩張圖和下面兩張圖分別為不同藥品，可以觀察到上面的藥品容易受到六日的干擾，程式篩選出異常資料時，可能會其中一種情形視為異常，但其實六日波動對於藥品消耗不是異常情形，改為週總和序列後可以弭平六日的影響，期能使程式將重點放在其他異常情形上。
***
## 程式規劃
由於 php 計算相關的數學模型需要付出的效能以及程式大小已經大大影響使用者體驗，所以偏好將計算與警示的工作交給 python ：
1. 用 python 將資料匯出資料庫後利用函式庫進行科學計算。
2. 形成中繼檔案交由 php 讀取。
3. 中繼的檔案格式不限，但開發時候便於閱讀所以選用 csv 檔。
4. php 在同一個網頁裡面丟給 chartjs 作圖。
![Alert program design](/images/2023-09-alert-design.png#center)

***
## 資料收集
我們需要將原始資料庫裡的資料作以下的整理：
1. 將每一筆消耗量以日期為群組進行相加，得到`日期：日消耗總和`的陣列或字典。
2. 將不連續的`日期：日消耗總和`資料補上連續日期資料，空值補 0 。
3. 將日期重新取樣成每週，並對資料再次進行相加，得到`週序：週消耗總和`的陣列或字典。
4. `週序`的表達方式無法直覺運用，可以改為星期日或星期一的日期。

先匯出資料庫中的資料，需要決定一個起始日期，例如一年前的當月月初：
```python
import pandas as pd
import numpy as np
import mysql.connector
from sqlalchemy import create_engine
engine = create_engine('mysql+mysqlconnector://~')

code = 'BOK001'

start_day = (pd.to_datetime('today') - pd.tseries.offsets.MonthBegin(13)).strftime('%Y%m%d')
today = pd.to_datetime('today').strftime('%Y%m%d')

# 查詢藥品用量資料
capital = '0' if code[0].isnumeric() else code[0]
sql = f"SELECT `date`,SUM(`total`) AS `qty` FROM `consmp_{capital}` WHERE `drug` = '{code}' AND `date` >= '{startday}' GROUP BY `date`"
df = pd.read_sql(sql, read_engine)
```

使日期成為連續資料：
```python
dayrange = pd.DataFrame(pd.date_range(start=start_day, end=today, freq='D').strftime('%Y%m%d'), columns=['date'])
df = pd.merge(dayrange, df, how='left', on='date').fillna(0)
```

將以上程式碼包成一個函式，但要小心有些藥品可能完全沒有被使用過，資料庫中不會有資料，所以需要增加預設值：
```python
def consmp(code):
    df['code'] = code
    ...
    if len(df) :
        ...
    else:
        df = pd.DataFrame(pd.date_range(start=start_day, end=today, freq='D').strftime('%Y%m%d'), columns=['date'])
        df['qty'] = 0
    
    return(df)
```

迭代藥品品項檔逐一輸出 `df` ，再使用 `concat` 方法： 
```python
# 建立空列表儲存各藥品的 df
dflist = []

medicine = pd.read_csv('藥品品項檔.csv')
for _,row in medicine.iterrows():
    # 將結果 append 進列表中
    dflist.append(consmp(row['code']))

df = pd.concat(dflist, axis=0, ignore_index=True)
```

把每日的資料重新取樣成每週的資料：
```python
# 強制轉換字串型別
df['qty'] = df['qty'].astype(int)
df['date'] = pd.to_datetime(df['date'], format='%Y%m%d')

#df = df.groupby('code').resample('W', on='date').sum() 本來採用 resample 方法，但效能不佳
df = df.groupby(by=['code', pd.Grouper(freq='W', key='date')]).sum()
df = df.reset_index().pivot_table(index='code', columns='date', values='qty')
df.columns = df.columns.to_series().dt.strftime('%Y%m%d')
# 顯示的日期是最後一天，如果是W，就是顯示禮拜日，也就資料是從禮拜一加到禮拜日

# 如果未滿整週就不要列出當週的資料
yesterday = (pd.to_datetime('today') - pd.tseries.offsets.DateOffset(days=1)).strftime('%Y%m%d')
if df.columns[-1] != yesterday:
    df = df.iloc[:,0:-1]
```
新的方法有點多，逐一來看效果。首先原本的 df 在轉換字串型別之後會長這樣：
![Alert Raw Data](/images/2023-09-alert-rawdata.png#center)

使用 `groupby().sum()` 會用 `code` 和重新取樣的 `date` 進行群組，剩下的資料 `qty` 進行加總 `sum()` ，其中 `freq` 的參數規則可以參考[這裡](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases)。這個 `Grouper` 功能很多也很複雜，有興趣可以自己在研究其他功能。取樣之後的資料會變成這樣：
![Alert Data Resampling](/images/2023-09-alert-resample.png#center)
因為這是有著 `multiindex` 的表格，個人習慣不以 index 來操作 DataFrame ，所以使用方法 `reset_index()` 扁平化資料，再以 `pivot_table()` 讓表格呈現下列的樣子：
![Alert Data Pivoting](/images/2023-09-alert-pivot.png#center)
最後因為目前 `columns` 的名稱型別是 `datetime` ，雖然預覽的表格顯示為 YYYY-MM-DD 格式，不過用 to_excel 輸出之後，其實還帶有更詳細的時間戳 HH:ii:ss.ssss 十分完整，因此需要以 `strftime()` 讓時間戳資料成為固定的字串，這樣接下來也比較好操作。
***
## 最後一點資料是不是離群值？
***
## 趨勢性顯不顯著？
***
## 時間序列預測的展望

### 機器學習
#### SARIMAX
#### Prophet

### 深度學習 RNNs
#### LSTM
#### GRU

***
## Attribution
- [Icons created by Freepik - Flaticon](https://www.flaticon.com/)